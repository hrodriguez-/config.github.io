<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Data Center Layout Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .controls {
            width: 320px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 20px rgba(0,0,0,0.1);
        }

        .viewer {
            flex: 1;
            position: relative;
            background: #ffffff;
        }

        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }

        .control-group h3 {
            color: #2c3e50;
            margin-bottom: 12px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        label {
            font-size: 12px;
            color: #555;
            flex: 1;
            margin-right: 10px;
        }

        input[type="number"], input[type="range"] {
            width: 80px;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 12px;
        }

        input[type="range"] {
            width: 100px;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            font-size: 12px;
            line-height: 1.4;
            backdrop-filter: blur(10px);
        }

        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 15px;
            margin-right: 8px;
            border-radius: 3px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #2c3e50;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h2 style="color: #2c3e50; margin-bottom: 20px; text-align: center;">Data Center Generator</h2>
            
            <div class="control-group">
                <h3>üìè Level Configuration</h3>
                <div class="input-row">
                    <label>Number of Levels:</label>
                    <input type="number" id="numberOfLevels" value="1" min="1" max="10">
                </div>
                <div class="input-row">
                    <label>Floor Height (ft):</label>
                    <input type="number" id="floorHeight" value="12" min="8" max="20" step="0.5">
                </div>
            </div>

            <div class="control-group">
                <h3>üè¢ Layout Dimensions</h3>
                <div class="input-row">
                    <label>Cabinet Depth (ft):</label>
                    <input type="number" id="cabinetDepth" value="8" min="6" max="12" step="0.5">
                </div>
                <div class="input-row">
                    <label>Number of Rows:</label>
                    <input type="number" id="numRows" value="4" min="2" max="20" step="2">
                </div>
                <div class="input-row">
                    <label>Cabinets per Row:</label>
                    <input type="number" id="cabinetsPerRow" value="20" min="10" max="50">
                </div>
                <div class="input-row">
                    <label>Cabinet Width (ft):</label>
                    <input type="number" id="cabinetWidth" value="2.5" min="2" max="4" step="0.1">
                </div>
                <div class="input-row">
                    <label>Cabinet Height (ft):</label>
                    <input type="number" id="cabinetHeight" value="7" min="6" max="8" step="0.1">
                </div>
            </div>

            <div class="control-group">
                <h3>üö∂ Aisle Widths</h3>
                <div class="input-row">
                    <label>Front Aisle (ft):</label>
                    <input type="number" id="frontAisle" value="12" min="8" max="16" step="0.5">
                </div>
                <div class="input-row">
                    <label>Rear Aisle (ft):</label>
                    <input type="number" id="rearAisle" value="12" min="8" max="16" step="0.5">
                </div>
                <div class="input-row">
                    <label>Side Aisle (ft):</label>
                    <input type="number" id="sideAisle" value="8" min="6" max="12" step="0.5">
                </div>
                <div class="input-row">
                    <label>Corridor Width (ft):</label>
                    <input type="number" id="corridorWidth" value="12" min="8" max="16" step="0.5">
                </div>
            </div>

            <div class="control-group">
                <h3>üîß Infrastructure</h3>
                <div class="input-row">
                    <label>Mechanical Depth (ft):</label>
                    <input type="number" id="mechanicalDepth" value="45" min="30" max="60" step="5">
                </div>
                <div class="input-row">
                    <label>Electrical Room (ft):</label>
                    <input type="number" id="electricalRoomWidth" value="36" min="24" max="48" step="6">
                </div>
                <div class="input-row">
                    <label>Generator Width (ft):</label>
                    <input type="number" id="generatorWidth" value="45" min="30" max="60" step="5">
                </div>
                <div class="input-row">
                    <label>Admin Length (ft):</label>
                    <input type="number" id="adminLength" value="70" min="40" max="100" step="5">
                </div>
                <div class="input-row">
                    <label>Parking Length (ft):</label>
                    <input type="number" id="parkingLength" value="20" min="10" max="40" step="5">
                </div>
            </div>

            <div class="control-group">
                <h3>‚ö° Power & Electrical</h3>
                <div class="input-row">
                    <label>kW per Cabinet:</label>
                    <input type="number" id="kwPerCabinet" value="10" min="5" max="25" step="0.5">
                </div>
                <div class="input-row">
                    <label>Load Factor (sq ft/kW):</label>
                    <input type="number" id="electricalLoadFactor" value="50" min="30" max="80" step="5">
                </div>
            </div>

            <div class="control-group">
                <h3>üìç Placement & Rotation</h3>
                <div class="input-row">
                    <label>Rotation (¬∞):</label>
                    <input type="range" id="rotationAngle" value="0" min="0" max="360" step="5">
                    <span id="rotationValue">0¬∞</span>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" onclick="generateLayout()">üîÑ Update Layout</button>
                <button class="btn btn-secondary" onclick="resetCamera()">üì∑ Reset View</button>
            </div>

            <div class="control-group">
                <h3>üìÑ Export Options</h3>
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="exportReport()">üìä Export Report</button>
                    <button class="btn btn-secondary" onclick="exportJSON()">üíæ Export JSON</button>
                </div>
            </div>
        </div>

        <div class="viewer">
            <div id="canvas-container"></div>
            <div class="loading" id="loading">Initializing 3D Engine...</div>
            
            <div class="info-panel" id="info-panel">
                <div id="facility-info"></div>
            </div>

            <div class="legend">
                <h4 style="margin-bottom: 10px;">Legend (Click to Toggle)</h4>
                <div class="legend-item" data-type="cabinet" onclick="toggleGeometry('cabinet')" style="cursor: pointer;">
                    <div class="legend-color" style="background: #e74c3c;"></div>
                    <span id="cabinet-label">Server Cabinets ‚úì</span>
                </div>
                <div class="legend-item" data-type="mechanical" onclick="toggleGeometry('mechanical')" style="cursor: pointer;">
                    <div class="legend-color" style="background: #3498db;"></div>
                    <span id="mechanical-label">Mechanical Areas ‚úì</span>
                </div>
                <div class="legend-item" data-type="electrical" onclick="toggleGeometry('electrical')" style="cursor: pointer;">
                    <div class="legend-color" style="background: #f39c12;"></div>
                    <span id="electrical-label">Electrical Areas ‚úì</span>
                </div>
                <div class="legend-item" data-type="admin" onclick="toggleGeometry('admin')" style="cursor: pointer;">
                    <div class="legend-color" style="background: #2ecc71;"></div>
                    <span id="admin-label">Admin Areas ‚úì</span>
                </div>
                <div class="legend-item" data-type="generator" onclick="toggleGeometry('generator')" style="cursor: pointer;">
                    <div class="legend-color" style="background: #9b59b6;"></div>
                    <span id="generator-label">Generator Areas ‚úì</span>
                </div>
                <div class="legend-item" data-type="corridor" onclick="toggleGeometry('corridor')" style="cursor: pointer;">
                    <div class="legend-color" style="background: #34495e;"></div>
                    <span id="corridor-label">Corridors ‚úì</span>
                </div>
                <div class="legend-item" data-type="floorSlab" onclick="toggleGeometry('floorSlab')" style="cursor: pointer;">
                    <div class="legend-color" style="background: #95a5a6;"></div>
                    <span id="floorSlab-label">Floor Slabs ‚úì</span>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global Three.js variables
        let scene, camera, renderer, controls;
        let facilityGroup = new THREE.Group();
        let dimensionGroup = new THREE.Group();
        
        // Geometry groups for visibility control
        let geometryGroups = {
            cabinet: new THREE.Group(),
            mechanical: new THREE.Group(),
            electrical: new THREE.Group(),
            admin: new THREE.Group(),
            generator: new THREE.Group(),
            corridor: new THREE.Group(),
            floorSlab: new THREE.Group()
        };

        // Visibility state
        let visibilityState = {
            cabinet: true,
            mechanical: true,
            electrical: true,
            admin: true,
            generator: true,
            corridor: true,
            floorSlab: true
        };

        // Store latest calculations for export
        let latestCalculations = null;
        let latestParams = null;

        // Materials
        const materials = {
            cabinet: new THREE.MeshLambertMaterial({ color: 0xe74c3c, transparent: true, opacity: 0.8 }),
            mechanical: new THREE.MeshLambertMaterial({ color: 0x3498db, transparent: true, opacity: 0.7 }),
            electrical: new THREE.MeshLambertMaterial({ color: 0xf39c12, transparent: true, opacity: 0.7 }),
            admin: new THREE.MeshLambertMaterial({ color: 0x2ecc71, transparent: true, opacity: 0.7 }),
            generator: new THREE.MeshLambertMaterial({ color: 0x9b59b6, transparent: true, opacity: 0.7 }),
            corridor: new THREE.MeshLambertMaterial({ color: 0x34495e, transparent: true, opacity: 0.6 }),
            floorSlab: new THREE.MeshLambertMaterial({ color: 0x95a5a6, transparent: true, opacity: 0.4 }),
            boundary: new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 }),
            dimension: new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 1 })
        };

        // Initialize Three.js scene
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            scene.fog = new THREE.Fog(0xffffff, 500, 2000);

            // Camera - positioned to look down at the ground-level facility
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 2000);
            // Initial position will be set after layout generation

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth - 320, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting - adjusted for white background
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(200, 300, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Add hemisphere light for better illumination on white background
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x2F4F4F, 0.3);
            scene.add(hemisphereLight);

            // Add a ground plane for reference
            const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xf0f0f0, 
                transparent: true, 
                opacity: 0.5 
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            ground.position.y = -1; // Slightly below the buildings
            scene.add(ground);

            // Simple orbit controls
            setupOrbitControls();

            // Add groups to scene
            Object.values(geometryGroups).forEach(group => {
                facilityGroup.add(group);
            });
            scene.add(facilityGroup);
            scene.add(dimensionGroup);

            // Initial layout generation
            generateLayout();
            
            // Set optimal camera position after layout generation
            resetCamera();

            // Start render loop
            animate();

            // Hide loading
            document.getElementById('loading').style.display = 'none';
        }

        // Simple orbit controls implementation
        function setupOrbitControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetX = 0, targetY = 0;
            let orbitCenter = new THREE.Vector3(0, 0, 0); // Will be updated with facility center
            
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            canvas.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                targetX += deltaX * 0.01;
                targetY += deltaY * 0.01;
                
                // Clamp vertical rotation to prevent flipping
                targetY = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, targetY));
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            canvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            canvas.addEventListener('wheel', (event) => {
                const currentDistance = camera.position.distanceTo(orbitCenter);
                const factor = event.deltaY > 0 ? 1.1 : 0.9;
                
                // Dynamic zoom limits based on facility size
                const minDistance = 20;
                const maxDistance = latestCalculations ? 
                    Math.max(latestCalculations.totalDataCenterWidth, latestCalculations.totalDataHallLength) * 2 : 
                    1000;
                
                const newDistance = Math.max(minDistance, Math.min(maxDistance, currentDistance * factor));
                
                // Maintain orbit around center
                const direction = camera.position.clone().sub(orbitCenter).normalize();
                camera.position.copy(orbitCenter).add(direction.multiplyScalar(newDistance));
            });
            
            // Update camera position to orbit around facility center
            function updateCamera() {
                const radius = camera.position.distanceTo(orbitCenter);
                const x = radius * Math.cos(targetY) * Math.cos(targetX);
                const y = radius * Math.sin(targetY);
                const z = radius * Math.cos(targetY) * Math.sin(targetX);
                
                camera.position.copy(orbitCenter).add(new THREE.Vector3(x, y, z));
                camera.lookAt(orbitCenter);
            }
            
            // Function to update orbit center
            window.updateOrbitCenter = function(center) {
                orbitCenter.copy(center);
                updateCamera();
            };
            
            // Add to animation loop
            const originalAnimate = window.animate;
            window.animate = function() {
                updateCamera();
                if (originalAnimate) originalAnimate();
            };
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Get input values
        function getInputValues() {
            return {
                numberOfLevels: parseInt(document.getElementById('numberOfLevels').value) || 1,
                cabinetDepth: parseFloat(document.getElementById('cabinetDepth').value) || 8.0,
                frontAisle: parseFloat(document.getElementById('frontAisle').value) || 12.0,
                rearAisle: parseFloat(document.getElementById('rearAisle').value) || 12.0,
                numRows: parseInt(document.getElementById('numRows').value) || 4,
                cabinetWidth: parseFloat(document.getElementById('cabinetWidth').value) || 2.5,
                cabinetsPerRow: parseInt(document.getElementById('cabinetsPerRow').value) || 20,
                sideAisle: parseFloat(document.getElementById('sideAisle').value) || 8.0,
                mechanicalDepth: parseFloat(document.getElementById('mechanicalDepth').value) || 45.0,
                corridorWidth: parseFloat(document.getElementById('corridorWidth').value) || 12.0,
                electricalRoomWidth: parseFloat(document.getElementById('electricalRoomWidth').value) || 36.0,
                generatorWidth: parseFloat(document.getElementById('generatorWidth').value) || 45.0,
                adminLength: parseFloat(document.getElementById('adminLength').value) || 70.0,
                parkingLength: parseFloat(document.getElementById('parkingLength').value) || 20.0,
                kwPerCabinet: parseFloat(document.getElementById('kwPerCabinet').value) || 10.0,
                electricalLoadFactor: parseFloat(document.getElementById('electricalLoadFactor').value) || 50.0,
                cabinetHeight: parseFloat(document.getElementById('cabinetHeight').value) || 7.0,
                floorHeight: parseFloat(document.getElementById('floorHeight').value) || 12.0,
                rotationAngle: parseFloat(document.getElementById('rotationAngle').value) || 0.0
            };
        }

        // Generate 3D layout
        function generateLayout() {
            const params = getInputValues();
            
            // Clear existing geometry
            Object.values(geometryGroups).forEach(group => group.clear());
            dimensionGroup.clear();

            // Validate inputs
            if (params.numRows % 2 !== 0) params.numRows += 1;

            // Core calculations
            const calculations = calculateDimensions(params);
            
            // Store for export
            latestCalculations = calculations;
            latestParams = params;
            
            // Generate 3D geometry
            generateFacilityGeometry(calculations, params);
            
            // Update info panel
            updateInfoPanel(calculations, params);
            
            // Update rotation display
            document.getElementById('rotationValue').textContent = params.rotationAngle + '¬∞';
        }

        // Calculate dimensions (ported from C# logic)
        function calculateDimensions(params) {
            const {
                numberOfLevels, cabinetDepth, frontAisle, rearAisle, numRows,
                cabinetWidth, cabinetsPerRow, sideAisle, mechanicalDepth,
                corridorWidth, electricalRoomWidth, generatorWidth,
                adminLength, parkingLength, kwPerCabinet, electricalLoadFactor,
                floorHeight
            } = params;

            // Power calculations
            const mwPerDataHall = (numRows * cabinetsPerRow * kwPerCabinet) / 1000.0;
            const totalMW = mwPerDataHall * numberOfLevels;

            // Length calculations
            const rowWidth = cabinetDepth + (0.5 * frontAisle) + corridorWidth + (0.5 * rearAisle);
            const coreDataHallLength = (rowWidth * numRows) + 8.0;
            const totalDataHallLength = coreDataHallLength + adminLength + parkingLength;

            // Width calculations with hallway logic
            const cabinetGroupSize = 24;
            const hallwayWidth = 8.0;
            const numberOfHallways = cabinetsPerRow > cabinetGroupSize ? 
                Math.ceil(cabinetsPerRow / cabinetGroupSize) - 1 : 0;
            const totalHallwayWidth = numberOfHallways * hallwayWidth;

            const cabinetAreaWidth = cabinetWidth * cabinetsPerRow;
            const cabinetWithHallwaysWidth = cabinetAreaWidth + totalHallwayWidth;
            const dataHallWidth = cabinetWithHallwaysWidth + (2 * sideAisle);
            const totalDataCenterWidth = generatorWidth + electricalRoomWidth + corridorWidth + 
                mechanicalDepth + dataHallWidth + corridorWidth + mechanicalDepth;

            // Multi-level calculations
            const totalBuildingHeight = floorHeight * numberOfLevels;

            // Layout coordinates
            const coords = {
                generatorStartX: 0,
                electricalStartX: generatorWidth,
                corridor1StartX: generatorWidth + electricalRoomWidth,
                leftMechanicalStartX: generatorWidth + electricalRoomWidth + corridorWidth,
                dataHallStartX: generatorWidth + electricalRoomWidth + corridorWidth + mechanicalDepth,
                dataHallEndX: generatorWidth + electricalRoomWidth + corridorWidth + mechanicalDepth + dataHallWidth,
                corridor2StartX: generatorWidth + electricalRoomWidth + corridorWidth + mechanicalDepth + dataHallWidth,
                rightMechanicalStartX: generatorWidth + electricalRoomWidth + corridorWidth + mechanicalDepth + dataHallWidth + corridorWidth,
                
                dataHallStartY: 0,
                dataHallEndY: coreDataHallLength,
                adminStartY: coreDataHallLength,
                adminEndY: coreDataHallLength + adminLength,
                parkingStartY: coreDataHallLength + adminLength,
                parkingEndY: coreDataHallLength + adminLength + parkingLength
            };

            return {
                mwPerDataHall,
                totalMW,
                rowWidth,
                coreDataHallLength,
                totalDataHallLength,
                cabinetAreaWidth,
                dataHallWidth,
                totalDataCenterWidth,
                totalBuildingHeight,
                numberOfHallways,
                totalHallwayWidth,
                coords,
                cabinetGroupSize,
                hallwayWidth
            };
        }

        // Generate 3D facility geometry
        function generateFacilityGeometry(calc, params) {
            const { coords } = calc;
            
            // Generate cabinet groups for proper spacing
            const cabinetGroups = [];
            let remainingCabinets = params.cabinetsPerRow;
            while (remainingCabinets > 0) {
                const groupSize = Math.min(remainingCabinets, calc.cabinetGroupSize);
                cabinetGroups.push(groupSize);
                remainingCabinets -= groupSize;
            }

            // Generate geometry for each level
            for (let level = 0; level < params.numberOfLevels; level++) {
                const levelElevation = level * params.floorHeight;
                
                // Floor slab - sits on the ground
                const slabGeometry = new THREE.BoxGeometry(
                    calc.totalDataCenterWidth, 
                    calc.totalDataHallLength, 
                    0.5
                );
                const floorSlab = new THREE.Mesh(slabGeometry, materials.floorSlab);
                floorSlab.position.set(
                    calc.totalDataCenterWidth / 2,
                    calc.totalDataHallLength / 2,
                    levelElevation + 0.25  // Half thickness above ground
                );
                geometryGroups.floorSlab.add(floorSlab);

                // Server cabinets with hallway logic - sitting on floor slab
                let currentCabinetX = coords.dataHallStartX + params.sideAisle;
                let totalCabinetsPlaced = 0;

                cabinetGroups.forEach((groupSize, groupIndex) => {
                    // Place cabinets in this group
                    for (let cabinetInGroup = 0; cabinetInGroup < groupSize; cabinetInGroup++) {
                        for (let row = 0; row < params.numRows; row++) {
                            const cabinetGeometry = new THREE.BoxGeometry(
                                params.cabinetWidth, 
                                params.cabinetDepth, 
                                params.cabinetHeight
                            );
                            const cabinet = new THREE.Mesh(cabinetGeometry, materials.cabinet);
                            
                            const individualRowDepth = calc.coreDataHallLength / params.numRows;
                            cabinet.position.set(
                                currentCabinetX + params.cabinetWidth / 2,
                                coords.dataHallStartY + (row * individualRowDepth) + (params.frontAisle * 0.5) + params.cabinetDepth / 2,
                                levelElevation + 0.5 + params.cabinetHeight / 2  // Sits on floor slab
                            );
                            geometryGroups.cabinet.add(cabinet);
                        }
                        currentCabinetX += params.cabinetWidth;
                        totalCabinetsPlaced++;
                    }
                    
                    // Add hallway space after group (except for last group)
                    if (totalCabinetsPlaced < params.cabinetsPerRow) {
                        currentCabinetX += calc.hallwayWidth;
                    }
                });

                // Infrastructure areas
                createInfrastructureAreas(level, levelElevation, calc, params, coords);
            }

            // Calculate facility center before applying rotations
            const facilityCenter = new THREE.Vector3(
                calc.totalDataCenterWidth / 2,
                calc.totalDataHallLength / 2,
                calc.totalBuildingHeight / 4  // Adjusted for better viewing angle
            );

            // First, rotate the entire facility to lay flat on the ground (Y becomes Z, Z becomes -Y)
            facilityGroup.rotation.x = -Math.PI / 2;
            
            // Then apply user rotation around the vertical axis
            if (params.rotationAngle !== 0) {
                const rotationRad = (params.rotationAngle * Math.PI) / 180;
                facilityGroup.rotation.z = rotationRad;
            }
            
            // Apply the same transformations to the center point for orbit controls
            const transformedCenter = facilityCenter.clone();
            transformedCenter.applyEuler(new THREE.Euler(-Math.PI / 2, 0, 0));
            if (params.rotationAngle !== 0) {
                const rotationRad = (params.rotationAngle * Math.PI) / 180;
                transformedCenter.applyEuler(new THREE.Euler(0, 0, rotationRad));
            }
            
            // Update orbit center
            if (window.updateOrbitCenter) {
                window.updateOrbitCenter(transformedCenter);
            }
        }

        // Create infrastructure areas for a level
        function createInfrastructureAreas(level, levelElevation, calc, params, coords) {
            const floorLevel = levelElevation + 0.5; // Account for floor slab thickness

            // Generator area (ground level only)
            if (level === 0) {
                const generatorGeometry = new THREE.BoxGeometry(
                    params.generatorWidth,
                    calc.coreDataHallLength,
                    params.floorHeight
                );
                const generator = new THREE.Mesh(generatorGeometry, materials.generator);
                generator.position.set(
                    coords.generatorStartX + params.generatorWidth / 2,
                    coords.dataHallStartY + calc.coreDataHallLength / 2,
                    floorLevel + params.floorHeight / 2  // Sits on floor slab
                );
                geometryGroups.generator.add(generator);
            }

            // Electrical room
            const electricalGeometry = new THREE.BoxGeometry(
                params.electricalRoomWidth,
                calc.coreDataHallLength,
                params.floorHeight
            );
            const electrical = new THREE.Mesh(electricalGeometry, materials.electrical);
            electrical.position.set(
                coords.electricalStartX + params.electricalRoomWidth / 2,
                coords.dataHallStartY + calc.coreDataHallLength / 2,
                floorLevel + params.floorHeight / 2  // Sits on floor slab
            );
            geometryGroups.electrical.add(electrical);

            // Corridors
            const corridor1Geometry = new THREE.BoxGeometry(
                params.corridorWidth,
                calc.coreDataHallLength,
                params.floorHeight
            );
            const corridor1 = new THREE.Mesh(corridor1Geometry, materials.corridor);
            corridor1.position.set(
                coords.corridor1StartX + params.corridorWidth / 2,
                coords.dataHallStartY + calc.coreDataHallLength / 2,
                floorLevel + params.floorHeight / 2  // Sits on floor slab
            );
            geometryGroups.corridor.add(corridor1);

            const corridor2 = new THREE.Mesh(corridor1Geometry, materials.corridor);
            corridor2.position.set(
                coords.corridor2StartX + params.corridorWidth / 2,
                coords.dataHallStartY + calc.coreDataHallLength / 2,
                floorLevel + params.floorHeight / 2  // Sits on floor slab
            );
            geometryGroups.corridor.add(corridor2);

            // Mechanical areas
            const mechanicalGeometry = new THREE.BoxGeometry(
                params.mechanicalDepth,
                calc.coreDataHallLength,
                params.floorHeight
            );
            
            const leftMechanical = new THREE.Mesh(mechanicalGeometry, materials.mechanical);
            leftMechanical.position.set(
                coords.leftMechanicalStartX + params.mechanicalDepth / 2,
                coords.dataHallStartY + calc.coreDataHallLength / 2,
                floorLevel + params.floorHeight / 2  // Sits on floor slab
            );
            geometryGroups.mechanical.add(leftMechanical);

            const rightMechanical = new THREE.Mesh(mechanicalGeometry, materials.mechanical);
            rightMechanical.position.set(
                coords.rightMechanicalStartX + params.mechanicalDepth / 2,
                coords.dataHallStartY + calc.coreDataHallLength / 2,
                floorLevel + params.floorHeight / 2  // Sits on floor slab
            );
            geometryGroups.mechanical.add(rightMechanical);

            // Admin area
            const adminGeometry = new THREE.BoxGeometry(
                calc.totalDataCenterWidth,
                params.adminLength,
                params.floorHeight
            );
            const admin = new THREE.Mesh(adminGeometry, materials.admin);
            admin.position.set(
                calc.totalDataCenterWidth / 2,
                coords.adminStartY + params.adminLength / 2,
                floorLevel + params.floorHeight / 2  // Sits on floor slab
            );
            geometryGroups.admin.add(admin);
        }

        // Update info panel
        function updateInfoPanel(calc, params) {
            const totalCabinets = params.numRows * params.cabinetsPerRow * params.numberOfLevels;
            const totalArea = calc.totalDataCenterWidth * calc.totalDataHallLength;
            
            const info = `
                <strong>Facility Summary</strong><br>
                <hr style="margin: 8px 0; border: 1px solid #444;">
                Levels: ${params.numberOfLevels}<br>
                Total Dimensions: ${calc.totalDataCenterWidth.toFixed(1)}' √ó ${calc.totalDataHallLength.toFixed(1)}'<br>
                Building Height: ${calc.totalBuildingHeight.toFixed(1)}'<br>
                Total Area: ${totalArea.toFixed(0)} sq ft<br>
                <br>
                <strong>Server Infrastructure</strong><br>
                <hr style="margin: 8px 0; border: 1px solid #444;">
                Cabinets per Level: ${params.numRows * params.cabinetsPerRow}<br>
                Total Cabinets: ${totalCabinets}<br>
                Power per Level: ${calc.mwPerDataHall.toFixed(2)} MW<br>
                Total Power: ${calc.totalMW.toFixed(2)} MW<br>
                <br>
                <strong>Layout Breakdown</strong><br>
                <hr style="margin: 8px 0; border: 1px solid #444;">
                Generator Width: ${params.generatorWidth}'<br>
                Electrical Width: ${params.electricalRoomWidth}'<br>
                Data Hall Width: ${calc.dataHallWidth.toFixed(1)}'<br>
                Mechanical Depth: ${params.mechanicalDepth}' (each side)<br>
                <br>
                Core Data Hall: ${calc.coreDataHallLength.toFixed(1)}'<br>
                Admin Area: ${params.adminLength}'<br>
                Parking Area: ${params.parkingLength}'
            `;
            
            document.getElementById('facility-info').innerHTML = info;
        }

        // Reset camera to default position
        function resetCamera() {
            if (latestCalculations) {
                const calc = latestCalculations;
                const params = latestParams;
                
                // Calculate facility center before transformations
                const facilityCenter = new THREE.Vector3(
                    calc.totalDataCenterWidth / 2,
                    calc.totalDataHallLength / 2,
                    calc.totalBuildingHeight / 4
                );
                
                // Apply same transformations as facility
                const transformedCenter = facilityCenter.clone();
                transformedCenter.applyEuler(new THREE.Euler(-Math.PI / 2, 0, 0));
                if (params.rotationAngle !== 0) {
                    const rotationRad = (params.rotationAngle * Math.PI) / 180;
                    transformedCenter.applyEuler(new THREE.Euler(0, 0, rotationRad));
                }
                
                // Position camera at optimal distance from facility center
                const optimalDistance = Math.max(calc.totalDataCenterWidth, calc.totalDataHallLength) * 0.8;
                camera.position.copy(transformedCenter).add(new THREE.Vector3(
                    optimalDistance * 0.6,
                    optimalDistance * 0.8,
                    optimalDistance * 0.6
                ));
                camera.lookAt(transformedCenter);
                
                // Update orbit center
                if (window.updateOrbitCenter) {
                    window.updateOrbitCenter(transformedCenter);
                }
            } else {
                // Fallback if no layout generated yet
                camera.position.set(300, 400, 300);
                camera.lookAt(0, 0, 0);
            }
        }

        // Toggle geometry visibility
        function toggleGeometry(type) {
            if (geometryGroups[type]) {
                visibilityState[type] = !visibilityState[type];
                geometryGroups[type].visible = visibilityState[type];
                
                // Update legend label
                const label = document.getElementById(type + '-label');
                const status = visibilityState[type] ? '‚úì' : '‚úó';
                label.textContent = label.textContent.replace(/[‚úì‚úó]/, status);
                
                // Update opacity based on visibility
                const legendItem = document.querySelector(`[data-type="${type}"]`);
                legendItem.style.opacity = visibilityState[type] ? '1.0' : '0.5';
            }
        }

        // Export comprehensive report
        function exportReport() {
            if (!latestCalculations || !latestParams) {
                alert('Please generate a layout first!');
                return;
            }

            const calc = latestCalculations;
            const params = latestParams;
            
            // Calculate additional metrics for the report
            const totalCabinets = params.numRows * params.cabinetsPerRow * params.numberOfLevels;
            const totalArea = calc.totalDataCenterWidth * calc.totalDataHallLength;
            const powerDensity = calc.totalMW / (totalArea / 1000); // MW per 1000 sq ft
            const cabinetDensity = totalCabinets / (totalArea / 1000); // Cabinets per 1000 sq ft
            
            // Generate comprehensive report
            const report = `=== MULTI-LEVEL DATA CENTER CALCULATOR - INFO ONLY ===

CALCULATION SUMMARY:
Original Mechanical Input: ${params.mechanicalDepth.toFixed(1)} ft
Validated Mechanical Depth: ${params.mechanicalDepth.toFixed(1)} ft
Left Mechanical Start X: ${calc.coords.leftMechanicalStartX.toFixed(1)} ft
Right Mechanical Start X: ${calc.coords.rightMechanicalStartX.toFixed(1)} ft
Total Calculated Width: ${calc.totalDataCenterWidth.toFixed(1)} ft

MULTI-LEVEL CONFIGURATION:
Number of Levels: ${params.numberOfLevels}
Floor Height: ${params.floorHeight.toFixed(1)} ft
Total Building Height: ${calc.totalBuildingHeight.toFixed(1)} ft
Level Elevations: ${Array.from({length: params.numberOfLevels}, (_, i) => `Level ${i+1}: ${(i * params.floorHeight).toFixed(1)} ft`).join(', ')}

POWER CALCULATIONS:
MW per Data Hall (M) = (E √ó H √ó L) √∑ 1,000
MW per Data Hall (M) = (${params.numRows} √ó ${params.cabinetsPerRow} √ó ${params.kwPerCabinet.toFixed(1)}) √∑ 1,000 = ${calc.mwPerDataHall.toFixed(2)} MW
Total MW (All Levels) = ${calc.mwPerDataHall.toFixed(2)} MW √ó ${params.numberOfLevels} levels = ${calc.totalMW.toFixed(2)} MW

LENGTH CALCULATION (F):
Layout (Front to Back): Data Hall ‚Üí Admin ‚Üí Parking
Row Width (D) = ${params.cabinetDepth.toFixed(1)} + (0.5√ó${params.frontAisle.toFixed(1)}) + ${params.corridorWidth.toFixed(1)} + (0.5√ó${params.rearAisle.toFixed(1)}) = ${calc.rowWidth.toFixed(1)} ft
Core Data Hall = (${calc.rowWidth.toFixed(1)} √ó ${params.numRows}) + 8 = ${calc.coreDataHallLength.toFixed(1)} ft
Total Length (F) = ${calc.coreDataHallLength.toFixed(1)} + ${params.adminLength.toFixed(1)} + ${params.parkingLength.toFixed(1)} = ${calc.totalDataHallLength.toFixed(1)} ft

WIDTH CALCULATION (K):
Layout (Left to Right): Generator ‚Üí Electrical ‚Üí Corridor ‚Üí Left Mech ‚Üí Data Hall ‚Üí Corridor ‚Üí Right Mech
Cabinets per Row: ${params.cabinetsPerRow}
Cabinet Groups: ${params.cabinetsPerRow}
Hallways Needed: ${calc.numberOfHallways} (after every ${calc.cabinetGroupSize} cabinets)
Generator Width: ${params.generatorWidth.toFixed(1)} ft
Electrical Width: ${params.electricalRoomWidth.toFixed(1)} ft
Corridor Width: ${params.corridorWidth.toFixed(1)} ft (√ó2 = ${(2 * params.corridorWidth).toFixed(1)} ft total)
Left Mechanical: ${params.mechanicalDepth.toFixed(1)} ft
Side Aisles: ${params.sideAisle.toFixed(1)} ft each (√ó2 = ${(2 * params.sideAisle).toFixed(1)} ft)
Cabinet Area: ${calc.cabinetAreaWidth.toFixed(1)} ft (calculated: ${params.cabinetWidth.toFixed(1)} √ó ${params.cabinetsPerRow})
Hallways: ${calc.totalHallwayWidth.toFixed(1)} ft (calculated: ${calc.numberOfHallways} √ó ${calc.hallwayWidth.toFixed(1)})
Right Mechanical: ${params.mechanicalDepth.toFixed(1)} ft
Total Width (K) = ${params.generatorWidth.toFixed(1)} + ${params.electricalRoomWidth.toFixed(1)} + ${params.corridorWidth.toFixed(1)} + ${params.mechanicalDepth.toFixed(1)} + ${calc.dataHallWidth.toFixed(1)} + ${params.corridorWidth.toFixed(1)} + ${params.mechanicalDepth.toFixed(1)} = ${calc.totalDataCenterWidth.toFixed(1)} ft

FACILITY DIMENSIONS:
Building Footprint: ${calc.totalDataHallLength.toFixed(1)} ft √ó ${calc.totalDataCenterWidth.toFixed(1)} ft = ${totalArea.toFixed(0)} sq ft
Total Building Volume: ${calc.totalDataHallLength.toFixed(1)} ft √ó ${calc.totalDataCenterWidth.toFixed(1)} ft √ó ${calc.totalBuildingHeight.toFixed(1)} ft = ${(totalArea * calc.totalBuildingHeight).toFixed(0)} cu ft
Core Data Hall per Level: ${calc.coreDataHallLength.toFixed(1)} ft √ó ${calc.dataHallWidth.toFixed(1)} ft = ${(calc.coreDataHallLength * calc.dataHallWidth).toFixed(0)} sq ft
Total Server Cabinets per Level: ${params.numRows * params.cabinetsPerRow} (${params.numRows} rows √ó ${params.cabinetsPerRow} cabinets)
Total Server Cabinets (All Levels): ${totalCabinets} (${params.numRows * params.cabinetsPerRow} √ó ${params.numberOfLevels} levels)

AREA BREAKDOWN:
Generator Area: ${params.generatorWidth.toFixed(1)} ft √ó ${calc.coreDataHallLength.toFixed(1)} ft = ${(params.generatorWidth * calc.coreDataHallLength).toFixed(0)} sq ft
Electrical Area: ${params.electricalRoomWidth.toFixed(1)} ft √ó ${calc.coreDataHallLength.toFixed(1)} ft = ${(params.electricalRoomWidth * calc.coreDataHallLength).toFixed(0)} sq ft
Mechanical Areas: ${params.mechanicalDepth.toFixed(1)} ft √ó ${calc.coreDataHallLength.toFixed(1)} ft √ó 2 = ${(params.mechanicalDepth * calc.coreDataHallLength * 2).toFixed(0)} sq ft
Data Hall Area: ${calc.dataHallWidth.toFixed(1)} ft √ó ${calc.coreDataHallLength.toFixed(1)} ft = ${(calc.dataHallWidth * calc.coreDataHallLength).toFixed(0)} sq ft
Admin Area: ${calc.totalDataCenterWidth.toFixed(1)} ft √ó ${params.adminLength.toFixed(1)} ft = ${(calc.totalDataCenterWidth * params.adminLength).toFixed(0)} sq ft
Parking Area: ${calc.totalDataCenterWidth.toFixed(1)} ft √ó ${params.parkingLength.toFixed(1)} ft = ${(calc.totalDataCenterWidth * params.parkingLength).toFixed(0)} sq ft

CAPACITY SUMMARY:
Total Power Capacity: ${calc.totalMW.toFixed(2)} MW
Total Server Cabinets: ${totalCabinets}
Total Facility Area: ${totalArea.toFixed(0)} sq ft
Power Density: ${powerDensity.toFixed(2)} MW per 1000 sq ft
Cabinet Density: ${cabinetDensity.toFixed(2)} cabinets per 1000 sq ft

Generated on: ${new Date().toLocaleString()}
Web Data Center Layout Generator v1.0`;

            // Create and download the report
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `DataCenter_Report_${new Date().toISOString().slice(0,10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Export JSON for Rhino
        function exportJSON() {
            if (!latestCalculations || !latestParams) {
                alert('Please generate a layout first!');
                return;
            }

            const calc = latestCalculations;
            const params = latestParams;
            
            // Collect all geometry data with Rhino-compatible coordinates
            const rhinoData = {
                metadata: {
                    version: "1.0",
                    generator: "Web Data Center Layout Generator",
                    timestamp: new Date().toISOString(),
                    coordinateSystem: "Right-handed (X=Width, Y=Length, Z=Height)",
                    units: "feet"
                },
                
                parameters: params,
                calculations: calc,
                
                geometry: {
                    cabinets: [],
                    mechanical: [],
                    electrical: [],
                    admin: [],
                    generator: [],
                    corridor: [],
                    floorSlab: []
                },
                
                summary: {
                    totalCabinets: params.numRows * params.cabinetsPerRow * params.numberOfLevels,
                    totalPower: calc.totalMW,
                    facilityDimensions: {
                        width: calc.totalDataCenterWidth,
                        length: calc.totalDataHallLength,
                        height: calc.totalBuildingHeight
                    },
                    areaBreakdown: {
                        totalArea: calc.totalDataCenterWidth * calc.totalDataHallLength,
                        generatorArea: params.generatorWidth * calc.coreDataHallLength,
                        electricalArea: params.electricalRoomWidth * calc.coreDataHallLength,
                        mechanicalArea: params.mechanicalDepth * calc.coreDataHallLength * 2,
                        dataHallArea: calc.dataHallWidth * calc.coreDataHallLength,
                        adminArea: calc.totalDataCenterWidth * params.adminLength,
                        parkingArea: calc.totalDataCenterWidth * params.parkingLength
                    }
                }
            };

            // Extract geometry from Three.js groups
            Object.keys(geometryGroups).forEach(type => {
                const group = geometryGroups[type];
                group.traverse((child) => {
                    if (child.isMesh && child.geometry.isBoxGeometry) {
                        const box = child.geometry;
                        const position = child.position;
                        
                        rhinoData.geometry[type].push({
                            type: "Box",
                            center: {
                                x: position.x,
                                y: position.y, 
                                z: position.z
                            },
                            dimensions: {
                                width: box.parameters.width,
                                height: box.parameters.height,
                                depth: box.parameters.depth
                            },
                            corners: {
                                min: {
                                    x: position.x - box.parameters.width / 2,
                                    y: position.y - box.parameters.height / 2,
                                    z: position.z - box.parameters.depth / 2
                                },
                                max: {
                                    x: position.x + box.parameters.width / 2,
                                    y: position.y + box.parameters.height / 2,
                                    z: position.z + box.parameters.depth / 2
                                }
                            }
                        });
                    }
                });
            });

            // Create and download the JSON
            const jsonString = JSON.stringify(rhinoData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `DataCenter_Layout_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = (window.innerWidth - 320) / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - 320, window.innerHeight);
        }

        // Event listeners
        window.addEventListener('resize', onWindowResize);
        
        // Auto-update on input changes
        document.querySelectorAll('input').forEach(input => {
            input.addEventListener('input', () => {
                if (input.type === 'range') {
                    document.getElementById('rotationValue').textContent = input.value + '¬∞';
                }
                generateLayout();
            });
        });

        // Initialize when page loads
        window.addEventListener('load', initThreeJS);
    </script>
</body>
</html>